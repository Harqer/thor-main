#!/usr/bin/env python3
"""
Fault-Tolerant Quantum Bitcoin Miner - Photonic Version (Quantum Only)
Uses Xanadu's photonic quantum computers via Blackbird circuit format.
"""

import argparse
import logging
import os
import time
import hashlib
from typing import Optional, List, Dict, Tuple
import numpy as np
import xcc
from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException
from tensorly.decomposition import tensor_train
from dotenv import load_dotenv

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class XanaduConnection:
    """Manages connection to Xanadu Cloud using proper XCC API"""

    def __init__(self, api_key: Optional[str] = None):
        if api_key:
            self.connection = xcc.Connection(refresh_token=api_key)
        else:
            self.connection = xcc.Connection.load()
        if not self.connection.ping().ok:
            raise ConnectionError("Failed to connect to Xanadu Cloud")
        logger.info("Successfully connected to Xanadu Cloud")

    def get_available_devices(self, status: Optional[str] = None) -> List[Dict]:
        devices = xcc.Device.list(self.connection, status=status)
        device_list = []
        for device in devices:
            info = {
                "target": device.target,
                "status": device.status,
                "up": device.up,
                "expected_uptime": device.expected_uptime,
                "overview": device.overview,
                "specification": device.specification,
                "certificate": device.certificate
            }
            uptime_str = "Always" if not device.expected_uptime else str(device.expected_uptime)
            logger.info(
                "Device: %s | Status: %s | Accepting jobs: %s | Uptime: %s",
                device.target,
                device.status,
                "Yes" if device.up else "No",
                uptime_str
            )
            device_list.append(info)
        return device_list

    def submit_blackbird_job(self, target: str, circuit: str, name: str) -> xcc.Job:
        job = self.connection.create_job(
            target=target,
            language="blackbird:1.0",
            circuit=circuit,
            name=name
        )
        logger.info("Job %s submitted to %s", job.id, target)
        return job

    def wait_for_job(self, job_id, timeout=300, poll_interval=5):
        t0 = time.time()
        while time.time() - t0 < timeout:
            res = self.connection.get_job(job_id)
            if res.status == "complete":
                return res
            if res.status == "failed":
                raise RuntimeError(f"Job {job_id} failed: {res.error}")
            elapsed = time.time() - t0
            logger.info("Job %s: %s, %.1fs", job_id, res.status, elapsed)
            time.sleep(poll_interval)
        raise TimeoutError(f"Job {job_id} timed out after {time.time() - t0:.1f}s")

def header_to_cv_features(header: dict, n_modes: int = 8) -> np.ndarray:
    header_str = str(header)
    header_bytes = header_str.encode("utf-8")
    bits = np.unpackbits(np.frombuffer(header_bytes, dtype=np.uint8))
    bits = np.pad(bits, (0, max(0, 64 - len(bits))), 'constant')[:64]
    tensor_shape = (2, 2, 2, 2, 2, 2, 2, 2)
    header_tensor = bits.reshape(tensor_shape).astype(np.float32)
    tt_cores = tensor_train(header_tensor, rank=2)
    features = []
    for core in tt_cores:
        features.extend(core.flatten())
    features = np.array(features[:n_modes * 2])
    feat_sq = features[:n_modes]
    sq_min = feat_sq.min()
    sq_max = feat_sq.max()
    squeezing_params = (feat_sq - sq_min) / (sq_max - sq_min + 1e-8)
    displacement_params = 4.0 * (features[n_modes:2 * n_modes] - 0.5)
    return np.concatenate([squeezing_params, displacement_params])

def build_entangled_header_nonce_tensor(headers: list, nonces: list, n_modes: int = 8) -> np.ndarray:
    batch = []
    for header in headers:
        nonce_vectors = []
        for nonce in nonces:
            candidate_header = header.copy()
            candidate_header['nonce'] = nonce
            features = header_to_cv_features(candidate_header, n_modes)
            nonce_vectors.append(features)
        batch.append(np.stack(nonce_vectors))
    tensor = np.stack(batch)  # shape: (num_headers, num_nonces, n_modes*2)
    return tensor

class BlackbirdCircuitBuilder:
    """Builds Blackbird circuits for Xanadu hardware"""

    @staticmethod
    def build_entangled_double_hash_circuit(tensor: np.ndarray, n_modes: int = 8, shots: int = 100) -> str:
        num_headers, num_nonces, _ = tensor.shape
        circuit = f"""
name entangled_double_hash
version 1.0
target X8_01 (shots={shots})

# Entangled input encoding
"""
        for h in range(num_headers):
            for n in range(num_nonces):
                squeezing = tensor[h, n, :n_modes]
                displacement = tensor[h, n, n_modes:2*n_modes]
                for i in range(n_modes):
                    circuit += f"Sgate({squeezing[i]:.6f}, 0) | {i}\n"
                    circuit += f"Dgate({displacement[i]:.6f}, 0) | {i}\n"
        for i in range(n_modes - 1):
            circuit += f"BSgate(np.pi/4, np.pi/2) | [{i}, {i+1}]\n"
        circuit += "\n# Measurement\n"
        modes = ", ".join(str(i) for i in range(n_modes))
        circuit += f"MeasureFock() | [{modes}]\n"
        return circuit

def double_sha256(header_bytes):
    return hashlib.sha256(hashlib.sha256(header_bytes).digest()).digest()

def serialize_header(header: dict) -> bytes:
    # Minimal serialization for Bitcoin block header (update as needed for full compliance)
    version = header['version'].to_bytes(4, 'little')
    prev_hash = bytes.fromhex(header['previousblockhash'])
    merkle_root = bytes.fromhex(header['merkleroot'])
    timestamp = header['curtime'].to_bytes(4, 'little')
    bits = bytes.fromhex(header['bits'])
    nonce = header['nonce'].to_bytes(4, 'little')
    return version + prev_hash + merkle_root + timestamp + bits + nonce

class PhotonicBitcoinMiner:
    """Complete photonic quantum Bitcoin miner using XCC API (Quantum Only)"""

    def __init__(self, device: str = "X8_01"):
        self.connection = XanaduConnection()
        self.device = device
        load_dotenv()
        rpc_url = os.getenv("BITCOIN_RPC_URL")
        rpc_user = os.getenv("BITCOIN_RPC_USER")
        rpc_password = os.getenv("BITCOIN_RPC_PASSWORD")
        if rpc_user and rpc_password and rpc_url:
            try:
                self.bitcoin_rpc = AuthServiceProxy(rpc_url)
                logger.info("Bitcoin RPC connected")
            except JSONRPCException as e:
                logger.warning("Bitcoin RPC not available: %s", e)
                self.bitcoin_rpc = None
        else:
            logger.warning("Bitcoin RPC credentials not found")
            self.bitcoin_rpc = None

    def get_block_templates(self, max_headers: int = 4):
        if not self.bitcoin_rpc:
            return []
        try:
            templates = []
            for _ in range(max_headers):
                template = self.bitcoin_rpc.getblocktemplate({"rules": ["segwit"]})
                templates.append(template)
            logger.info("Got %d block templates", len(templates))
            return templates
        except Exception as e:
            logger.error("Failed to get block templates: %s", e)
            return []

    def mine_entangled_batch(self, block_headers: list, candidate_nonces: list, n_modes: int = 8, shots: int = 100):
        logger.info("Quantum mining with entangled headers and nonces...")
        tensor = build_entangled_header_nonce_tensor(block_headers, candidate_nonces, n_modes)
        circuit = BlackbirdCircuitBuilder.build_entangled_double_hash_circuit(tensor, n_modes, shots)
        job = self.connection.submit_blackbird_job(self.device, circuit, "entangled_batch_mining")
        result = self.connection.wait_for_job(job.id)
        output = result.get("output", [])
        logger.info("Quantum mining output: %s", output)
        # Validate quantum output and submit valid blocks
        found = self.validate_and_submit(block_headers, candidate_nonces, output)
        if found:
            logger.info("Valid block found and submitted to network.")
        else:
            logger.info("No valid block found in quantum output.")
        return found

    def validate_and_submit(self, block_headers, candidate_nonces, output):
        # For each header and nonce, reconstruct and check hash
        for h_idx, header in enumerate(block_headers):
            for n_idx, nonce in enumerate(candidate_nonces):
                candidate_header = header.copy()
                candidate_header['nonce'] = nonce
                header_bytes = serialize_header(candidate_header)
                hash_result = double_sha256(header_bytes)
                hash_int = int.from_bytes(hash_result, 'big')
                target = header['target']
                if hash_int < target:
                    logger.info("Valid block found! Header idx: %d, Nonce: %d, Hash: %064x", h_idx, nonce, hash_int)
                    if self.bitcoin_rpc:
                        try:
                            self.bitcoin_rpc.submitblock(header_bytes.hex())
                            logger.info("Block submitted to network.")
                        except Exception as e:
                            logger.error("Block submission failed: %s", e)
                    return True
        return False

def main():
    parser = argparse.ArgumentParser(description="Photonic Quantum Bitcoin Miner (Quantum Only)")
    parser.add_argument("--device", default="X8_01", help="Xanadu device (X8_01, simulon_gaussian, borealis)")
    parser.add_argument("--max-headers", type=int, default=4, help="Maximum block headers to process in parallel")
    parser.add_argument("--max-nonces", type=int, default=16, help="Maximum nonces per header")
    parser.add_argument("--n-modes", type=int, default=8, help="Number of quantum modes")
    parser.add_argument("--shots", type=int, default=100, help="Number of quantum shots")
    args = parser.parse_args()
    miner = PhotonicBitcoinMiner(device=args.device)
    block_headers = miner.get_block_templates(max_headers=args.max_headers)
    if not block_headers:
        logger.warning("No block headers - using demo template")
        block_headers = [{
            'version': 536870912,
            'previousblockhash': '00'*32,
            'merkleroot': '00'*32,
            'curtime': int(time.time()),
            'bits': '207fffff',
            'height': 1,
            'target': int('7fffff0000000000000000000000000000000000000000000000000000000000', 16)
        }] * args.max_headers
    candidate_nonces = list(np.random.randint(0, 2**32, size=args.max_nonces))
    found = miner.mine_entangled_batch(block_headers, candidate_nonces, n_modes=args.n_modes, shots=args.shots)
    if found:
        logger.info("Mining succeeded: Valid block submitted.")
    else:
        logger.info("Mining completed: No valid block found.")

if __name__ == "__main__":
    main()